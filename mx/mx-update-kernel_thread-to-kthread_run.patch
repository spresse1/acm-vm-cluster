diff -rupN mx-1.2.16-orig/driver/linux/mx_arch_klib.h mx-1.2.16/driver/linux/mx_arch_klib.h
--- mx-1.2.16-orig/driver/linux/mx_arch_klib.h	2013-05-14 23:46:47.644295112 -0400
+++ mx-1.2.16/driver/linux/mx_arch_klib.h	2013-05-15 00:47:51.481347107 -0400
@@ -63,7 +63,11 @@ mx_klib_thread_create(mx_klib_thread_t *
 		      int (*func)(void *), void *arg) {
   int ret;
   init_completion(threadp);
+#if defined(HAVE_LINUX_KTHREAD_RUN)
+  ret = kthread_run(func, arg, "Generic MX kernel thread");
+#else
   ret = kernel_thread(func, arg, CLONE_FS|CLONE_FILES);
+#endif
   return ret >= 0 ? 0 : -ret;
 }
 
diff -rupN mx-1.2.16-orig/driver/linux/mx.c mx-1.2.16/driver/linux/mx.c
--- mx-1.2.16-orig/driver/linux/mx.c	2013-05-14 23:46:46.827290921 -0400
+++ mx-1.2.16/driver/linux/mx.c	2013-05-15 00:41:24.654472813 -0400
@@ -3184,7 +3184,11 @@ mx_init_module (void)
   
   init_completion(&mx_watchdog_completion);
   init_waitqueue_head(&mx_watchdog_queue);
+#if defined(HAVE_LINUX_KTHREAD_RUN)
+  if (IS_ERR(kthread_run(mx_watchdog_thread, 0, "MX Watchdog thread"))) {
+#else
   if (kernel_thread(mx_watchdog_thread, 0, CLONE_FS | CLONE_FILES) < 0) {
+#endif
     MX_WARN(("Cannot start the watchdog thread: No Parity recovery\n"));
     complete(&mx_watchdog_completion);
   }
